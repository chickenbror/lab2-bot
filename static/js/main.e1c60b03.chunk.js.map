{"version":3,"sources":["chartparser.js","runparser.js","grammars/meetingGrammar.ts","dmAppointmentPro.ts","index.tsx","srgs.js"],"names":["LOG","str","clone","obj","temp","constructor","key","isEmpty","ob","i","hasOwnProperty","Chart","numberOfWords","this","passives","Array","actives","add","edge","subchart","cat","isPassive","start","lhs","end","next","content","resultsForRule","results","finalEdges","push","out","allEdges","allPassiveEdges","concat","allActiveEdges","edges","j","k","statistics","length","nrEdges","nrPassiveEdges","nrActiveEdges","PassiveEdge","_string","toString","ActiveEdge","rest","rules","text","parse","words","grammar","root","filter","$root","chart","agenda","leftCornerFilter","addToChart","inference","rhs","slice","SRGS","min","max","oneof","eval","undefined","ruleref","position","leftCorners","pop","active","join","ref","passive","processRuleExpansions","xrule","xitems","childNodes","rule","nodeType","textContent","trim","split","nodeName","uri","getAttribute","repeat","r","parseInt","Infinity","console","log","gram","dom","DOMParser","parseFromString","ActiveXObject","doc","XML","newDocument","loadXML","url","encodeURIComponent","request","XMLHttpRequest","open","send","responseXML","parseXML","getElementsByTagName","xrules","loadGrammar","parseMeeting","input","meeting","result","toLowerCase","time","day","whatsMissing","context","prompt","missing","person","weekday","knownSoFar","atTime","withPerson","onDay","say","_context","type","value","promptAndAsk","promptEvent","initial","states","entry","on","ENDSPEECH","ask","nomatch","dmMachine","init","CLICK","stop","always","restart","welcome","RECOGNISED","cond","recResult","actions","assign","target","transit","askMore","final","answer","includes","sayYes","sayNo","done","inspect","iframe","machine","Machine","id","dm","asrtts","idle","LISTEN","SPEAK","event","ttsAgenda","recognising","exit","ASRRESULT","progress","match","speaking","recLogResult","test","logIntent","nluData","intent","name","ReactiveButton","props","state","matches","className","style","animation","App","useSpeechSynthesis","onEnd","speak","cancel","useSpeechRecognition","onResult","listen","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","ttsStart","effect","ttsCancel","current","onClick","rootElement","document","getElementById","ReactDOM","Grammar","VOID","OneOf","NULL","GARBAGE","$check","checkSequenceExpansion","err","throwRuleError","Ref","RefClass","Tag","tag","TagClass","alternatives","OneOfClass","Repeat","sequence","RepeatClass","message","error","TypeError","String","checkExpansion","prototype","Number"],"mappings":"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","file":"static/js/main.e1c60b03.chunk.js","sourcesContent":["//\r\n//  chartparser.js\r\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\r\n//\r\n/*\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU Lesser General Public License as published \r\n  by the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n  \r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n  \r\n  You should have received a copy of the GNU General Public License\r\n  and the GNU Lesser General Public License along with this program.  \r\n  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/* Mods by Torbjörn\r\n- Removed the toString() method from Object. Why does it still work?\r\n- Added a text variable (similar to rules). See \r\n*/\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// a logging function\r\n//  - uncomment if you want to debug the parsing process\r\nfunction LOG(str) {\r\n  //console.log(\"\" + str);\r\n}\r\n\r\nimport * as SRGS from './srgs'\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// we need to be able to clone objects between different edges\r\n// borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\r\nfunction clone(obj){\r\n  if (obj == null || typeof(obj) != 'object') {\r\n    return obj;\r\n  }\r\n  var temp = new obj.constructor(); \r\n  for (var key in obj) {\r\n    temp[key] = clone(obj[key]);\r\n  }\r\n  return temp;\r\n}\r\n\r\n\r\nfunction isEmpty(ob){\r\n   for (var i in ob) { if(ob.hasOwnProperty(i)) {return false;}}\r\n  return true;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// parse chart\r\n// conceptually this is a set of edges, but it is optimized\r\nfunction Chart(numberOfWords) {\r\n  this.numberOfWords = numberOfWords;\r\n  this.passives = new Array(numberOfWords);\r\n  this.actives = new Array(numberOfWords);\r\n  for (var i = 0; i <= numberOfWords; i++) {\r\n    this.passives[i] = {};\r\n    this.actives[i] = {};\r\n  }\r\n\r\n  // Chart.add(edge)\r\n  // add the edge to the chart, return true if the chart was changed \r\n  // (i.e. if the chart didn't already contain the edge)\r\n  this.add = function add(edge) {\r\n    var subchart, cat;\r\n    if (edge.isPassive) {\r\n      subchart = this.passives[edge.start];\r\n      cat = edge.lhs;\r\n    } else {\r\n      subchart = this.actives[edge.end];\r\n      cat = edge.next.content;\r\n    }\r\n    if (!(cat in subchart)) {\r\n      subchart[cat] = {};\r\n    }\r\n    if (edge in subchart[cat]) {\r\n      return false;\r\n    } else {\r\n      subchart[cat][edge] = edge;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // Chart.resultsForRule(lhs, start, end)\r\n  // return all parse results for the given lhs, start, and end\r\n  //  - start, end are optional; defaults to 0, numberOfWords\r\n  this.resultsForRule = function resultsForRule(lhs, start, end) {\r\n    start = start || 0;\r\n    end = end || numberOfWords;\r\n    var results = [];\r\n    var finalEdges = this.passives[start][lhs];\r\n    for (var i in finalEdges) {\r\n      if (finalEdges[i].end == end) {\r\n\tresults.push(finalEdges[i].out);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n  \r\n  // Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\r\n  // return an array of all (passive/active) edges in the chart\r\n  this.allEdges = function allEdges() {\r\n    return this.allPassiveEdges().concat(this.allActiveEdges());\r\n  }\r\n  this.allPassiveEdges = function allPassiveEdges() {\r\n    var edges = [];\r\n    for (var i in this.passives) \r\n      for (var j in this.passives[i]) \r\n\tfor (var k in this.passives[i][j])\r\n\t  edges.push(this.passives[i][j][k]);\r\n    return edges;\r\n  }\r\n  this.allActiveEdges = function allActiveEdges() {\r\n    var edges = [];\r\n    for (var i in this.actives) \r\n      for (var j in this.actives[i]) \r\n\tfor (var k in this.actives[i][j])\r\n\t  edges.push(this.actives[i][j][k]);\r\n    return edges;\r\n  }\r\n\r\n  // Chart.statistics()\r\n  // return the number of edges in the chart\r\n  this.statistics = function statistics() {\r\n    var passives = this.allPassiveEdges().length;\r\n    var actives = this.allActiveEdges().length;\r\n    return {nrEdges: passives+actives, nrPassiveEdges: passives, nrActiveEdges: actives};\r\n  }\r\n}\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// parse edges: passive and active\r\n\r\nfunction PassiveEdge(start, end, lhs, out) {\r\n  this.start = start;\r\n  this.end = end;\r\n  this.lhs = lhs;\r\n  this.out = out;\r\n  this.isPassive = true;\r\n\r\n  var str = \"[\" + start + \"-\" + end + \"] $\" + lhs + \" := \" + out;\r\n  this._string = str;\r\n  this.toString = function toString() {return this._string;} \r\n}\r\n\r\nfunction ActiveEdge(start, end, lhs, next, rest, out, rules, text) {\r\n  this.start = start;\r\n  this.end = end;\r\n  this.lhs = lhs;\r\n  this.next = next;\r\n  this.rest = rest;\r\n  this.out = out;\r\n  this.rules = rules;\r\n  this.text = text;\r\n  this.isPassive = false;\r\n\r\n  var str = \"<\" + start + \"-\" + end + \"> $\" + lhs + \" -> \" + next + \r\n    \", \" + rest + \" := \" + out + \" <- \" + rules;\r\n  this._string = str;\r\n  this.toString = function toString() {return this._string;} \r\n}\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// the main parsing function: a simple top-down chartparser\r\n//  - 'words' is an array of strings\r\n//  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\r\n//  - 'root' is the starting category (a string)\r\n//    if unspecified, use the '$root' property of the grammar\r\n//  - 'filter' is an optional left-corner filter \r\n//    (a mapping from categories/rule-refs to words)\r\n//    if specified, it is used when predicting new edges\r\n// returns the final chart\r\nexport function parse(words, grammar, root, filter) {\r\n  if (!root) {\r\n    root = grammar.$root;\r\n  }\r\n  var chart = new Chart(words.length);\r\n  var agenda = [];\r\n\r\n  var leftCornerFilter;\r\n  if (filter == undefined) {\r\n    leftCornerFilter = function() {return true};\r\n  } else {\r\n    leftCornerFilter = function leftCornerFilter(ruleref, position) {\r\n      var leftCorners = filter[ruleref];\r\n      return leftCorners ? words[position] in leftCorners : true;\r\n    }\r\n  }\r\n  \r\n  // add an edge to the chart and the agenda, if it does not already exist\r\n  function addToChart(inference, start, end, lhs, rhs, out, rules, text) {\r\n    var edge;\r\n    if (rhs.length > 0) {\r\n      var next = rhs[0];\r\n      var rest = rhs.slice(1);\r\n      switch (next.constructor) {\r\n\t\r\n      case Array:\r\n\t// the next symbol is a sequence\r\n\taddToChart(inference+\",SEQUENCE\", start, end, lhs, next.concat(rest), out, rules, text);\r\n\treturn;\r\n\t\r\n      case SRGS.RepeatClass:\r\n\t// the next symbol is a repetition\r\n\tvar min = next.min;\r\n\tvar max = next.max;\r\n\t// skip repeat \r\n\tif (min <= 0) {\r\n\t  addToChart(inference+\",SKIP\", start, end, lhs, rest, out, rules, text);\r\n\t}\r\n\t// repeat \r\n\tif (max > 0) {\r\n\t  var content = next.content;\r\n\t  var rhs = (max==1 ? [content] : [content, SRGS.Repeat(min ? min-1 : min, max-1, content)]);\r\n\t  addToChart(inference+\",REPEAT\", start, end, lhs, rhs.concat(rest), out, rules, text);\r\n\t}\r\n\treturn;\r\n\t\r\n      case SRGS.OneOfClass:\r\n\t// the next symbol is a disjunction\r\n\tvar oneof = next.content;\r\n\tfor (var i in oneof) {\r\n\t  var rhs = oneof[i].concat(rest);\r\n\t  addToChart(inference+\",ONEOF\", start, end, lhs, rhs, out, rules, text);\r\n\t} \r\n\treturn;\r\n\t\r\n      case SRGS.TagClass:\r\n\t// the next symbol is a semantic action\r\n\tout = clone(out);\r\n\trules = clone(rules);\r\n\teval(next.content);\r\n\taddToChart(inference+\",TAG\", start, end, lhs, rest, out, rules, text);\r\n\treturn;\r\n      }\r\n\r\n      edge = new ActiveEdge(start, end, lhs, next, rest, out, rules, text);\r\n    } else {\r\n      edge = new PassiveEdge(start, end, lhs, out);\r\n    }\r\n    \r\n    // try to add the edge; if successful, also add it to the agenda\r\n    if (chart.add(edge)) {\r\n      LOG(\"+ \" + inference + \": \" + edge);\r\n      agenda.push(edge);\r\n    }\r\n  }\r\n  \r\n  // seed the agenda with the starting rule\r\n  addToChart(\"INIT\", 0, 0, root, grammar[root], {}, {}, {});\r\n  \r\n  // main loop\r\n  while (agenda.length > 0) {\r\n    var edge = agenda.pop();\r\n    var start= edge.start;\r\n    var end  = edge.end;\r\n    var lhs  = edge.lhs;\r\n    var next = edge.next;\r\n    LOG(edge);\r\n\r\n    if (edge.isPassive) {\r\n      // combine\r\n      var actives = chart.actives[start][lhs];\r\n      for (var i in actives) {\r\n\tvar active = actives[i];\r\n\tvar rules = clone(active.rules);\r\n\tvar text = active.text;\r\n\ttext[edge.lhs] = words.slice(start, end).join(\" \");\r\n\tif (typeof edge.out == 'object' && isEmpty(edge.out)) {\r\n\t    rules[edge.lhs] = text[edge.lhs];\r\n\t} else {\r\n        rules[edge.lhs] = clone(edge.out);\r\n    }\r\n\taddToChart(\"COMBINE\", active.start, end, active.lhs, active.rest, active.out, rules, text);\r\n      }\r\n\r\n    } else if (next.constructor == SRGS.RefClass) {\r\n      var ref = next.content;\r\n      // combine\r\n      var passives = chart.passives[end][ref];\r\n      for (var i in passives) {\r\n\tvar passive = passives[i];\r\n\tvar rules = clone(edge.rules);\r\n\tvar text = edge.text;\r\n\trules[passive.lhs] = clone(passive.out);\r\n\ttext[passive.lhs] = passive.text;\r\n\taddToChart(\"COMBINE\", start, passive.end, lhs, edge.rest, edge.out, rules, text);\r\n      }\r\n      // predict\r\n      if (ref in grammar) {\r\n\tif (leftCornerFilter(ref, end)) {\r\n\t  addToChart(\"PREDICT\", end, end, ref, grammar[ref], {}, {}, {});\r\n\t}\r\n      }\r\n\r\n    } else if (next == words[end]) {\r\n      // scan\r\n      addToChart(\"SCAN\", start, end+1, lhs, edge.rest, edge.out, edge.rules, edge.text);\r\n    }\r\n  }\r\n\r\n  return chart;\r\n}\r\n\r\n\r\n","//\r\n//  runparser.js\r\n//\r\n/*\r\n  The author or authors of this code dedicate any and all \r\n  copyright interest in this code to the public domain.\r\n*/\r\n\r\n\r\n// helper functions for the parser demo\r\n\r\nimport * as SRGS from './srgs'\r\n\r\nfunction getElement(id) {\r\n  return document.getElementById(id);\r\n}\r\n\r\nfunction appendElement(parent, element, text) {\r\n  var elem = document.createElement(element);\r\n  if (text)\r\n    elem.appendChild(document.createTextNode(text));\r\n  parent.appendChild(elem);\r\n  return elem\r\n}\r\n\r\nfunction runParser(input) {\r\n  var resultsDiv = getElement(\"results\");\r\n  resultsDiv.innerHTML = \"\";\r\n  var maybeFilter;\r\n  if (getElement(\"usefilter\") && getElement(\"usefilter\").checked) {\r\n    maybeFilter = filter;\r\n    appendElement(resultsDiv, \"EM\", \"Using left-corner filter\");\r\n  }\r\n  var startTime = new Date();\r\n  var parseChart = parse(input, grammar, grammar.$root, maybeFilter);\r\n  var parseTime = new Date() - startTime;\r\n  var parseResults = parseChart.resultsForRule(grammar.$root);\r\n  \r\n  console.log(parseResults[0]);\r\n  \r\n  if (parseResults) {\r\n    for (var i in parseResults) {\r\n        resultsDiv.innerHTML += display(parseResults[i],\"\");\r\n    }\r\n  } else {\r\n    appendElement(resultsDiv, \"P\", \"No results found!\");\r\n  }\r\n  \r\n/*\r\n  if (parseResults) { \r\n    var resultList = appendElement(resultsDiv, \"OL\");\r\n    for (var i in parseResults) \r\n      appendElement(resultList, \"LI\", JSON.stringify(parseResults[i]));\r\n  } else {\r\n    appendElement(resultsDiv, \"P\", \"No results found!\");\r\n  }\r\n*/\r\n  var statistics = parseChart.statistics()\r\n  appendElement(resultsDiv, \"P\", \"Chart size: \" + statistics.nrEdges + \" edges\" +\r\n\t\t\" (\" + statistics.nrPassiveEdges + \" passive)\");\r\n  appendElement(resultsDiv, \"P\", \"Parse time: \" + parseTime + \" ms\" + \r\n\t\t\" (\" + (parseTime / statistics.nrEdges).toFixed(2) + \" ms/edge)\");\r\n}\r\n\r\nfunction runWordParser() {\r\n  runParser(getElement(\"input\").value.split(/\\s+/));\r\n}\r\n\r\nfunction runCharacterParser() {\r\n  runParser(getElement(\"input\").value.split(\"\"));\r\n}\r\n\r\nexport function loadGrammar(str) {\r\n    var dom = parseXML(str);\r\n    var root = dom.getElementsByTagName(\"grammar\")[0].getAttribute(\"root\");\r\n    var grammar = new SRGS.Grammar(root);\r\n    var xrules = dom.getElementsByTagName(\"rule\");\r\n    for(var r=0; r < xrules.length; r++) {\r\n        var xrule = xrules[r];\r\n        var id = xrule.getAttribute(\"id\");\r\n        grammar[id] = processRuleExpansions(xrule);\r\n    }\r\n    return grammar;\r\n}\r\n\r\nfunction processRuleExpansions(xrule) {\r\n    var xitems = xrule.childNodes;\r\n    var rule = [];\r\n    for(var i=0; i < xitems.length; i++) {\r\n        if (xitems[i].nodeType == 3) {\r\n            var str = xitems[i].textContent.trim();\r\n            if (str != \"\") {\r\n                rule.push(str.split(/ +/));\r\n            }\r\n        } else if (xitems[i].nodeType == 1) {\r\n            if (xitems[i].nodeName == \"token\") {\r\n                rule.push(SRGS.Tag(xitems[i].textContent));\r\n            } else if (xitems[i].nodeName == \"ruleref\") {\r\n                var uri = xitems[i].getAttribute(\"uri\");\r\n                rule.push(SRGS.Ref(uri.slice(1)));\r\n            } else if (xitems[i].nodeName == \"tag\") {\r\n                rule.push(SRGS.Tag(xitems[i].textContent.trim()));\r\n            } else if (xitems[i].nodeName == \"one-of\") {\r\n                rule.push(SRGS.OneOf(processRuleExpansions(xitems[i])));\r\n            } else if (xitems[i].nodeName == \"item\") {\r\n                var repeat = xitems[i].getAttribute(\"repeat\");\r\n                if (!repeat) {\r\n                    rule.push(processRuleExpansions(xitems[i]));\r\n                } else {\r\n                    var r = repeat.split(\"-\");\r\n                    var min = parseInt(r[0]);\r\n                    var max = parseInt(r[1]);\r\n                    max = (max) ? max : Infinity;\r\n                    rule.push(SRGS.Repeat(min, max, processRuleExpansions(xitems[i])));\r\n                }\r\n            } else {\r\n                console.log(xitems[i]);\r\n            }\r\n        }\r\n    }\r\n\treturn rule;\r\n}\r\n\r\nfunction parseXML(text) {\r\n    if (typeof DOMParser != \"undefined\") {\r\n        // Mozilla, Firefox, and related browsers\r\n        return (new DOMParser()).parseFromString(text, \"application/xml\");\r\n    }\r\n    else if (typeof ActiveXObject != \"undefined\") {\r\n        // Internet Explorer.\r\n        var doc = XML.newDocument();  // Create an empty document\r\n        doc.loadXML(text);            // Parse text into it\r\n        return doc;                   // Return it\r\n    }\r\n    else {\r\n        // As a last resort, try loading the document from a data: URL\r\n        // This is supposed to work in Safari. Thanks to Manos Batsis and\r\n        // his Sarissa library (sarissa.sourceforge.net) for this technique.\r\n        var url = \"data:text/xml;charset=utf-8,\" + encodeURIComponent(text);\r\n        var request = new XMLHttpRequest();\r\n        request.open(\"GET\", url, false);\r\n        request.send(null);\r\n        return request.responseXML;\r\n    }\r\n};\r\n","/*\r\n\r\n$root mymeeting\r\n\r\n$mymeeting [$Please] [$Meet] [$Person] [$Day] [$Time] [$Please] [punctuation];\r\n\r\n$Please please|thanks|thank you ...\r\n$Meet meet|create a meeting with| I'm meeting ...\r\n$Person [with] Donald|Mickey|... \r\n$Day [on] Monday|Tuesday|Wednesday...\r\n$Time [at] noon|1|2|... [a.m.|p.m.] | [for][the] all day|whole day|entire day\r\n\r\n>>Returns Object.meeting.person/day/time;  a property=undefined if an item is not mentioned\r\n>>When saying 2 or more items, person-day-time may be in any order (eg, 'at 10 with Mickey' also works)\r\n**Names of people are lowercase as ASR applies sentence capitalisation, which causes SRGS to fail to recognise 'Meet...',\r\n  so I lowercase all the recognised strings in dmAppointmentPro\r\n\r\n*/\r\n\r\nexport const grammar = `\r\n<grammar root=\"mymeeting\">\r\n  <rule id=\"mymeeting\">\r\n    \r\n    <item repeat=\"0-\"><ruleref uri=\"#Politeness\"/></item>\r\n\t\r\n    <item repeat=\"0-1\"><ruleref uri=\"#MakeMeeting\"/></item>\r\n\r\n    <!--Six different orders-->\r\n    <one-of>  \r\n        <item> <item repeat=\"0-1\"><ruleref uri=\"#person\"/></item><item repeat=\"0-1\"><ruleref uri=\"#day\"/></item><item repeat=\"0-1\"><ruleref uri=\"#time\"/></item> </item>\r\n        <item> <item repeat=\"0-1\"><ruleref uri=\"#person\"/></item><item repeat=\"0-1\"><ruleref uri=\"#time\"/></item><item repeat=\"0-1\"><ruleref uri=\"#day\"/></item> </item> \r\n        <item> <item repeat=\"0-1\"><ruleref uri=\"#day\"/></item><item repeat=\"0-1\"><ruleref uri=\"#person\"/></item><item repeat=\"0-1\"><ruleref uri=\"#time\"/></item> </item>\r\n        <item> <item repeat=\"0-1\"><ruleref uri=\"#day\"/></item><item repeat=\"0-1\"><ruleref uri=\"#time\"/></item><item repeat=\"0-1\"><ruleref uri=\"#person\"/></item> </item>\r\n        <item> <item repeat=\"0-1\"><ruleref uri=\"#time\"/></item><item repeat=\"0-1\"><ruleref uri=\"#day\"/></item><item repeat=\"0-1\"><ruleref uri=\"#person\"/></item> </item>\r\n        <item> <item repeat=\"0-1\"><ruleref uri=\"#time\"/></item><item repeat=\"0-1\"><ruleref uri=\"#person\"/></item><item repeat=\"0-1\"><ruleref uri=\"#day\"/></item> </item>   \r\n    </one-of>\r\n    \r\n    <item repeat=\"0-\"><ruleref uri=\"#Politeness\"/></item>\r\n    <item repeat=\"0-\">.</item><item repeat=\"0-\">!</item><item repeat=\"0-\">?</item>\r\n    \r\n    <tag>\r\n     out.meeting=new Object();\r\n     out.meeting.person= rules.person; \r\n     out.meeting.day= rules.day; \r\n     out.meeting.time= rules.time; \r\n    </tag>\r\n    \r\n  </rule> \r\n\r\n   //Polite Expressions//\r\n   <rule id=\"Politeness\">\r\n        <one-of>  \r\n            <item> please </item> <item> thanks </item> <item> thank you </item> \r\n\t\t\t<item> could you </item> <item> would you </item> <item> can you </item> \r\n\t\t\t<item> will you </item> <item> i would like to </item> \r\n        </one-of>\r\n   </rule>\r\n\r\n  \r\n   //Make Meeting Command//\r\n   <rule id=\"MakeMeeting\">\r\n        <one-of>  \r\n            <item> create a meeting </item> <item> create an appointment </item> \r\n\t\t\t<item> make a meeting </item> <item> make an appointment </item>\r\n            <item> we have a meeting </item> <item> have a meeting </item>\r\n            <item> i am meeting </item> <item> i'm meeting </item> <item> meet </item> <item> i have a meeting </item>\r\n            <item> meeting </item> \r\n        </one-of>\r\n   </rule>\r\n\r\n   //People//\r\n   <rule id=\"person\"> <item repeat=\"0-1\">with</item>\r\n        <one-of>  \r\n            \r\n            <item> john <tag> out=\"John Appleseed\" </tag></item>  \r\n            <item> goofy <tag> out=\"Goofy Dog\" </tag></item> \r\n            <item> mickey <tag> out=\"Mickey Mouse\" </tag></item> \r\n            <item> minnie <tag> out=\"Minnie Mouse\" </tag></item> \r\n            <item> donald <tag> out=\"Donald Duck\" </tag></item> \r\n            <item> daisy <tag> out=\"Daisy Duck\" </tag></item> \r\n            <item> lisa <tag> out=\"Lisa Simpson\" </tag></item> \r\n            <item> homer <tag> out=\"Homer Simpson\" </tag></item> \r\n            <item> monty <tag> out=\"Montgomery Burns\" </tag></item> \r\n            <item> apu <tag> out=\"Apu Nahasapeemapetilon\" </tag></item> \r\n\r\n        </one-of>\r\n   </rule>\r\n   \r\n   //Days//\r\n    <rule id=\"day\"> <item repeat=\"0-1\">on</item>\r\n        <one-of> \r\n            <item> monday </item> <item> tuesday </item> <item> wednesday </item>\r\n            <item> thursday </item> <item> friday </item> <item> saturday </item>\r\n            <item> sunday </item>\r\n        </one-of> \r\n    </rule>\r\n\r\n   //Times//\r\n    <rule id=\"time\"> \r\n        <one-of> \r\n            <item>\r\n                <item repeat=\"0-1\">at</item>\r\n                <one-of> \r\n                    <item> noon <tag>out=\"12 p.m.\";</tag></item> \r\n                    <item> midnight <tag>out=\"12 a.m.\";</tag></item> \r\n                    <item>1</item> <item>2</item> <item>3</item> <item>4</item> <item>5</item>\r\n                    <item>6</item> <item>7</item> <item>8</item> <item>9</item> <item>10</item>\r\n                    <item>11</item> <item>12</item>\r\n                </one-of>\r\n\r\n                <item repeat=\"0-1\">\r\n                  <one-of> \r\n                    <item> a.m. </item> <item> p.m. </item>\r\n                  </one-of>\r\n                </item>\r\n            </item>\r\n\r\n            <item> <tag> out='whole day'; </tag>\r\n                <item repeat=\"0-1\">for</item>\r\n                <item repeat=\"0-1\">the</item>\r\n                <one-of>\r\n                <item> whole day </item> <item> all day </item> <item> entire day </item>\r\n                </one-of>\r\n            </item>\r\n\r\n        </one-of>\r\n\r\n    </rule>\r\n   \r\n</grammar>\r\n`\r\n","import { MachineConfig, actions, Action, assign, send } from \"xstate\";\r\n\r\n// SRGS parser and example (logs the results to console on page load)\r\nimport { loadGrammar } from './runparser'\r\nimport { parse } from './chartparser'\r\nimport { grammar } from './grammars/meetingGrammar'\r\n\r\nconst gram = loadGrammar(grammar)\r\n\r\n// Parse recognised speech to an object with 3 properties\r\nfunction parseMeeting(input:string) {\r\n\r\n    let prs = parse(input.toLowerCase().split(/\\s+/), gram)\r\n    let result = prs.resultsForRule(gram.$root)[0]\r\n\r\n    let meeting ; //undefined if input cannot be parsed\r\n    if (result!=undefined) {\r\n        meeting = result.meeting;\r\n        // remove the prepositions 'at','on' \r\n        if(!!meeting.time && meeting.time.slice(0,3)==='at '){\r\n            meeting.time=meeting.time.slice(3) };\r\n        if(!!meeting.day && meeting.day.slice(0,3)==='on '){\r\n            meeting.day=meeting.day.slice(3) };\r\n        }\r\n    return meeting \r\n    }\r\n\r\n\r\nfunction whatsMissing(context:SDSContext){\r\n    let missing=[]\r\n    if(!context.person){missing.push(\"with whom\")}\r\n    if(!context.weekday){missing.push(\"on which day\")}\r\n    if(!context.time){missing.push(\"at what time\")}\r\n    \r\n    let prompt;\r\n    if (missing.length===0) {prompt=`I have all the details of your meeting!`};\r\n    if (missing.length===1) {prompt=`Tell me ${missing[0]} you are meeting`};\r\n    if (missing.length===2) {prompt=`Tell me ${missing[0]}, and ${missing[1]} is your meeting`};\r\n    if (missing.length===3) {prompt=`Tell me ${missing[0]}, ${missing[1]}, and ${missing[2]} is the meeting`};\r\n    return prompt\r\n}\r\n\r\n\r\n// const sayWhatsMissing: Action<SDSContext, SDSEvent> = send((context: SDSContext) => ({\r\n//     type: \"SPEAK\", value: whatsMissing(context)\r\n// }))\r\n\r\n\r\nfunction knownSoFar(context:SDSContext){\r\n    let withPerson=(!!context.person)? 'with '+context.person : ''\r\n    let onDay=(!!context.weekday)? 'on '+context.weekday : ''\r\n    let atTime;\r\n    if(!!context.time){\r\n        atTime=(context.time === 'whole day')? 'for the whole day' : 'at '+context.time \r\n        }\r\n    else{atTime=''}\r\n\r\n    return `${withPerson} ${onDay} ${atTime}`\r\n}\r\n\r\n\r\nfunction say(text: string): Action<SDSContext, SDSEvent> {\r\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\r\n}\r\n\r\nfunction sharedRecognitions() {\r\n    return [\r\n        { target: 'stop', cond: (context:SDSContext) => context.recResult === 'stop' },\r\n        { target: 'restart', cond: (context:SDSContext) => context.recResult === 'restart' },\r\n        { target: \".nomatch\" }\r\n        ]\r\n}\r\n\r\nfunction promptAndAsk(promptEvent: Action<SDSContext, SDSEvent>): MachineConfig<SDSContext, any, SDSEvent> {\r\n    return ({\r\n        initial: 'prompt',\r\n        states: {\r\n            prompt: {\r\n                entry: promptEvent,\r\n                on: { ENDSPEECH: 'ask' }\r\n            },\r\n            ask: {\r\n                entry: send('LISTEN'),\r\n            },\r\n            nomatch: { entry: [say(\"Sorry, I didnt get that\")],  \r\n                       on: { ENDSPEECH: \"prompt\" } \r\n            },\r\n        }\r\n    })\r\n}\r\n\r\nfunction sayYes(answer: string){\r\n    let yes=[\"yes\", \"of course\", \"sure\", \"absolutely\", \"yeah\", \"yep\", \"okay\",]\r\n    if(yes.includes(answer)){ return true }\r\n}\r\n\r\nfunction sayNo(answer: string){\r\n    let yes=[\"no\", \"nope\", \"no thanks\", \"nah\",]\r\n    if(yes.includes(answer)){ return true }\r\n}\r\n\r\n/*\r\nISSUES AND DESIGN CHOICES\r\n\r\nI did not use orthogonal states, instead each property is treated as a slot to be filled (to context.slot_name).\r\nAs long as a slot is unfilled (===undefined), the system will keep prompting for more information and update \r\nthe context slots accordingly (but only with new information, ie, the already-filled slots won't be overwritten).\r\n\r\nAn issue I encountered was that the ASR automatically capitalises the first letter of a sentence and adding full stop at the end,\r\nwhich will cause the grammar parser to fail to recognise it. So I lowercase the input string, but that means that the <item> person_name </item>\r\nand words like 'I' in the SRXML must be written in lowercase too.\r\n\r\n\r\n*/\r\n\r\n\r\n\r\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\r\n    initial: 'init',\r\n    states: {\r\n        init: {\r\n            on: {\r\n                CLICK: 'start'\r\n            }\r\n        },\r\n        stop: {\r\n            entry: say(\"Ok, stopped\"),\r\n            always: 'init'\r\n        },\r\n        start: {\r\n            entry: say(\"Lets make an appointment. \"),\r\n            // always: 'welcome'\r\n            on: { ENDSPEECH: \"welcome\" }\r\n        },\r\n        restart: {\r\n            entry: say(\"Ok, starting over\"),\r\n            // always: 'welcome'\r\n            on: { ENDSPEECH: \"welcome\" } \r\n        },\r\n\r\n        //01\r\n        welcome: {\r\n            on: {\r\n                RECOGNISED: [\r\n                    \r\n                    //Update context as long as parsed grammar object is not undefined\r\n                    {\r\n                    cond: (context) => !!parseMeeting(context.recResult),\r\n                    actions: assign((context) => { return { person: parseMeeting(context.recResult).person,\r\n                                                            weekday:parseMeeting(context.recResult).day,\r\n                                                            time: parseMeeting(context.recResult).time,\r\n                         } }),\r\n                    target: \"transit\"\r\n                    },\r\n                    ...sharedRecognitions(),\r\n\r\n                ]},\r\n                ...promptAndAsk( say(\"Tell me the meeting details.\") )\r\n        },\r\n        \r\n        //02\r\n        transit:{\r\n            always: [\r\n                //All slots filled\r\n                { target: 'final', cond: (context) => !!context.person && !!context.weekday && !!context.time },\r\n\r\n                //At least one slot unfilled\r\n                { target: 'askMore', cond: (context) => !context.person || !context.weekday || !context.time },\r\n\r\n            ]\r\n        },\r\n\r\n        //03 \r\n        askMore: {\r\n            on: {\r\n                RECOGNISED: [\r\n                    \r\n                    //Update context as long as parsed grammar object is not undefined\r\n                    // ONLY update unfilled slots (ie, undefined properties)\r\n\r\n                    //Missing 1 slot >> update 1 slot:\r\n                    { cond: (context) => !!parseMeeting(context.recResult) && !!context.weekday && !!context.time,\r\n                      actions: assign((context) => { return { person: parseMeeting(context.recResult).person}  } ),\r\n                      target: \"transit\"   },\r\n                    { cond: (context) => !!parseMeeting(context.recResult) && !!context.person  && !!context.time,\r\n                      actions: assign((context) => { return { weekday: parseMeeting(context.recResult).day}  } ),\r\n                      target: \"transit\"   },\r\n                    { cond: (context) => !!parseMeeting(context.recResult) && !!context.person && !!context.weekday,\r\n                      actions: assign((context) => { return { time: parseMeeting(context.recResult).time}  } ),\r\n                      target: \"transit\"   },\r\n\r\n                    //Missing 2 slots >> update 2 slots:\r\n                    { cond: (context) => !!parseMeeting(context.recResult) && !context.person && !context.weekday,\r\n                        actions: assign((context) => { return { person: parseMeeting(context.recResult).person, weekday: parseMeeting(context.recResult).day}  } ),\r\n                        target: \"transit\"   },\r\n                    { cond: (context) => !!parseMeeting(context.recResult) && !context.person && !context.time,\r\n                        actions: assign((context) => { return { person: parseMeeting(context.recResult).person, time: parseMeeting(context.recResult).time}  } ),\r\n                        target: \"transit\"   },\r\n                    { cond: (context) => !!parseMeeting(context.recResult) && !context.weekday && !context.time,\r\n                        actions: assign((context) => { return { weekday: parseMeeting(context.recResult).day, time: parseMeeting(context.recResult).time}  } ),\r\n                        target: \"transit\"   },\r\n                    \r\n                    //Missing 3 slots: \r\n                    ...sharedRecognitions(),\r\n\r\n                ]},\r\n            ...promptAndAsk( send((context) => ({ type: \"SPEAK\", value: whatsMissing(context)+knownSoFar(context)+'?' })) )\r\n\r\n        },\r\n\r\n        //04\r\n        final:{\r\n            on: {\r\n                RECOGNISED: [\r\n                    { cond: (context) => sayYes(context.recResult)===true, target: \"done\"   },\r\n                    { cond: (context) => sayNo(context.recResult)===true, target: \"restart\"   }, \r\n                    ...sharedRecognitions(),\r\n\r\n                ]},\r\n            ...promptAndAsk( send((context) => ({ \r\n                type: \"SPEAK\", \r\n                value: `Meeting ${knownSoFar(context)}. Was that correct?` \r\n                })) )\r\n        },\r\n\r\n        //05\r\n        done: {\r\n            entry: say(\"Great, your appointment has been made.\"), \r\n            on: { ENDSPEECH: \"init\" } \r\n           },\r\n        \r\n    },\r\n\r\n})","import \"./styles.scss\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { Machine, assign, send, State } from \"xstate\";\r\nimport { useMachine, asEffect } from \"@xstate/react\";\r\nimport { inspect } from \"@xstate/inspect\";\r\nimport { dmMachine } from './dmAppointmentPro';\r\n\r\n\r\ninspect({\r\n    url: \"https://statecharts.io/inspect\",\r\n    iframe: false\r\n});\r\n\r\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\r\n\r\n\r\nconst machine = Machine<SDSContext, any, SDSEvent>({\r\n    id: 'root',\r\n    type: 'parallel',\r\n    states: {\r\n        dm: {\r\n            ...dmMachine\r\n        },\r\n        asrtts: {\r\n            initial: 'idle',\r\n            states: {\r\n                idle: {\r\n                    on: {\r\n                        LISTEN: 'recognising',\r\n                        SPEAK: {\r\n                            target: 'speaking',\r\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\r\n                        }\r\n                    }\r\n                },\r\n                recognising: {\r\n                    initial: 'progress',\r\n                    entry: 'recStart',\r\n                    exit: 'recStop',\r\n                    on: {\r\n                        ASRRESULT: {\r\n                            actions: ['recLogResult',\r\n                                assign((_context, event) => { return { recResult: event.value } })],\r\n                            target: '.match'\r\n                        },\r\n                        // TIMEOUT:\"..recStop\", //mic off so that say() can work\r\n                        RECOGNISED: 'idle'\r\n                    },\r\n                    states: {\r\n                        progress: {\r\n                        },\r\n                        match: {\r\n                            entry: send('RECOGNISED'),\r\n                        },\r\n                    }\r\n                },\r\n                speaking: {\r\n                    entry: 'ttsStart',\r\n                    on: {\r\n                        ENDSPEECH: 'idle',\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n},\r\n    {\r\n        actions: {\r\n            recLogResult: (context: SDSContext) => {\r\n                /* context.recResult = event.recResult; */\r\n                console.log('<< ASR: ' + context.recResult);\r\n\r\n            },\r\n            test: () => {\r\n                console.log('test')\r\n            },\r\n            logIntent: (context: SDSContext) => {\r\n                /* context.nluData = event.data */\r\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\r\n            }\r\n        },\r\n    });\r\n\r\n\r\n\r\ninterface Props extends React.HTMLAttributes<HTMLElement> {\r\n    state: State<SDSContext, any, any, any>;\r\n}\r\nconst ReactiveButton = (props: Props): JSX.Element => {\r\n    switch (true) {\r\n        case props.state.matches({ asrtts: 'recognising' }):\r\n            return (\r\n                <button type=\"button\" className=\"glow-on-hover\"\r\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\r\n                    Listening...\r\n                </button>\r\n            );\r\n        case props.state.matches({ asrtts: 'speaking' }):\r\n            return (\r\n                <button type=\"button\" className=\"glow-on-hover\"\r\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\r\n                    Speaking...\r\n                </button>\r\n            );\r\n        default:\r\n            return (\r\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\r\n                    Click to start\r\n                </button >\r\n            );\r\n    }\r\n}\r\n\r\nfunction App() {\r\n    const { speak, cancel, speaking } = useSpeechSynthesis({\r\n        onEnd: () => {\r\n            send('ENDSPEECH');\r\n        },\r\n    });\r\n    const { listen, listening, stop } = useSpeechRecognition({\r\n        onResult: (result: any) => {\r\n            send({ type: \"ASRRESULT\", value: result });\r\n        },\r\n    });\r\n    const [current, send, service] = useMachine(machine, {\r\n        devTools: true,\r\n        actions: {\r\n            recStart: asEffect(() => {\r\n                console.log('Ready to receive a voice input.');\r\n                listen({\r\n                    interimResults: false,\r\n                    continuous: true\r\n                });\r\n            }),\r\n            recStop: asEffect(() => {\r\n                console.log('Recognition stopped.');\r\n                stop()\r\n            }),\r\n            ttsStart: asEffect((context, effect) => {\r\n                console.log('Speaking...');\r\n                speak({ text: context.ttsAgenda })\r\n            }),\r\n            ttsCancel: asEffect((context, effect) => {\r\n                console.log('TTS STOP...');\r\n                cancel()\r\n            }),\r\n            speak: asEffect((context) => {\r\n\t            console.log('Speaking...');\r\n                speak({text: context.ttsAgenda })\r\n            }) \r\n        }\r\n    });\r\n\r\n\r\n    return (\r\n        <div className=\"App\">\r\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\n\r\n/* RASA API\r\n *  */\r\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\r\nconst rasaurl = 'https://guess-the-intent.herokuapp.com/model/parse'\r\nconst nluRequest = (text: string) =>\r\n    fetch(new Request(proxyurl + rasaurl, {\r\n        method: 'POST',\r\n        headers: { 'Origin': 'http://maraev.me' }, // only required with proxy\r\n        body: `{\"text\": \"${text}\"}`\r\n        })\r\n        )\r\n        .then(data => data.json());\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nReactDOM.render(\r\n    <App />,\r\n    rootElement);\r\n","//\r\n//  srgs.js\r\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\r\n//\r\n/*\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU Lesser General Public License as published \r\n  by the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n  \r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n  \r\n  You should have received a copy of the GNU General Public License\r\n  and the GNU Lesser General Public License along with this program.  \r\n  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// encoding SRGS grammars in javascript\r\n\r\nexport function Grammar(root) {\r\n  this.$root = root;\r\n  \r\n  this.VOID = [OneOf([])];\r\n  this.NULL = [];\r\n  this.GARBAGE = []; \r\n  \r\n  this.$check = function() {\r\n    for (var i in this) {\r\n      if (i !== \"$root\" && i !== \"$check\") {\r\n\ttry {\r\n\t  checkSequenceExpansion(this[i]);\r\n\t} catch(err) {\r\n\t  throwRuleError(\"When checking grammar rule '\" + i + \"'\", err);\r\n\t}\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function WordSet(str) {\r\n  var words = str.split(/ +/);\r\n  var set = {};\r\n  for (var i in words) {\r\n    set[words[i]] = true;\r\n  }\r\n  return set;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// rule expansion constructors\r\n\r\n// sequences are ordinary arrays\r\nexport function Sequence(seq) {\r\n  return seq;\r\n}\r\n\r\nexport function Ref(ref) {\r\n  return new RefClass(ref);\r\n}\r\n\r\nexport function Tag(tag) {\r\n  return new TagClass(tag);\r\n}\r\n\r\nexport function OneOf(alternatives) {\r\n  return new OneOfClass(alternatives);\r\n}\r\n\r\nexport function Repeat(min, max, sequence) {\r\n  return new RepeatClass(min, max, sequence);\r\n}\r\n\r\nexport function Optional(sequence) {\r\n  return new RepeatClass(0, 1, sequence);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// rule expansion classes\r\n\r\nexport function RefClass(ruleref) {\r\n  this.content = ruleref;\r\n  this._string = \"$\" + ruleref;\r\n  this.toString = function toString() {return this._string}\r\n}\r\n    \r\nexport function TagClass(tag) {\r\n  this.content = tag;\r\n  this._string = \"{\" + tag + \"}\";\r\n  this.toString = function toString() {return this._string}\r\n}\r\n\r\nexport function OneOfClass(alternatives) {\r\n  this.content = alternatives;\r\n  this._string = \"(\" + alternatives.join(\"|\") + \")\";\r\n  this.toString = function toString() {return this._string}\r\n}\r\n\r\nexport function RepeatClass(min, max, sequence) {\r\n  this.min = min;\r\n  this.max = max;\r\n  this.content = sequence;\r\n  this._string = this.content + \"<\" + this.min + \"-\" + (this.max==Infinity ? \"\" : this.max) + \">\"\r\n  this.toString = function toString() {return this._string}\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// checking rule expansions\r\n\r\nexport function throwRuleError(message, error) {\r\n  if (error == undefined) {\r\n    throw TypeError(message);\r\n  } else {\r\n    throw TypeError(message + \"; \" + error.message);\r\n  }\r\n}\r\n\r\nexport function checkSequenceExpansion(sequence) {\r\n  try {\r\n    if (sequence.constructor !== Array) {\r\n      throwRuleError(\"Expected Array, found \" + sequence.constructor.name);\r\n    }\r\n    for (var i in sequence) {\r\n      if (sequence[i].constructor == Array) {\r\n\tcheckSequenceExpansion(sequence[i]);\r\n      } else if (sequence[i].constructor != String) {\r\n\tsequence[i].checkExpansion();\r\n      }\r\n    }\r\n  } catch(err) {\r\n    throwRuleError(\"When checking sequence expansion\", err);\r\n  }\r\n};\r\n\r\nRefClass.prototype.checkExpansion = function checkExpansion() {\r\n  if (this.content.constructor !== String) {\r\n    throwRuleError(\"When checking Ref content; Expected String, found \" + this.content.constructor.name);\r\n  }\r\n};\r\n\r\nTagClass.prototype.checkExpansion = function checkExpansion() {\r\n  if (this.content.constructor !== String) {\r\n      throwRuleError(\"When checking Tag content; Expected String, found \" + this.content.constructor.name);\r\n  }\r\n};\r\n\r\nOneOfClass.prototype.checkExpansion = function checkExpansion() {\r\n  try {\r\n    if (this.content.constructor !== Array) {\r\n      throwRuleError(\"Expected Array, found \" + this.content.constructor.name);\r\n    }\r\n    for (var i in this.content) {\r\n      checkSequenceExpansion(this.content[i]);\r\n    }\r\n  } catch(err) {\r\n    throwRuleError(\"When checking OneOf content\", err);\r\n  }\r\n};\r\n\r\nRepeatClass.prototype.checkExpansion = function checkExpansion() {\r\n  try {\r\n    if (this.min.constructor !== Number || this.max.constructor !== Number) {\r\n      throwRuleError(\"Expected min/max to be Number, found \" + this.min.constructor.name + \"/\" + this.max.constructor.name);\r\n    }\r\n    if (!(0 <= this.min && this.min <= this.max)) {\r\n      throwRuleError(\"Expected 0 <= min <= max, found \" + this.min + \"/\" + this.max);\r\n    }\r\n    checkSequenceExpansion(this.content);\r\n  } catch(err) {\r\n    throwRuleError(\"When checking Repeat content\", err);\r\n  }\r\n};\r\n\r\n"],"sourceRoot":""}